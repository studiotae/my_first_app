# 【開発日記】学習資料整理アプリ「耐-TAE」の仕組み解説

このアプリは、学習資料（ノート、試験問題、プリントなど）をカメラでスキャンし、**Gemini AI**が自動で分類してくれるFlutterアプリです。

---

## � **超初心者向け：プログラミングの基本から** 

### ①そもそもプログラムって何？
プログラムは**レシピ**のようなもので、コンピューターに「何をするか」を順番に書いた指示書です。

**例えば：料理のレシピ**
```
1. 水を鍋に入れる
2. 火をつける
3. 沸騰したら麺を入れる
4. 3分待つ
5. お湯を捨てる
6. ソースを入れる
```

**プログラムも同じ：**
```dart
1. アプリを起動する
2. カメラを開く
3. 写真を撮る
4. AIに送信する
5. 分類結果を表示する
```

コンピューターは上から下に、書かれた通りに実行します。

---

### ②importって何？

**importは「道具箱を持ってくる」こと**

料理で例えると：
- 「フライパンを持ってくる」
- 「包丁を持ってくる」
- 「塩と砂糖を持ってくる」

プログラムでも同じで、必要な機能を持ってきます。

```dart
import 'package:flutter/material.dart';  // 画面を作る道具
import 'package:image_picker/image_picker.dart';  // カメラを使う道具
import 'db_helper.dart';  // データベースを使う自分の道具
```

**このアプリで使ってる主な「道具」：**
- `flutter/material.dart` → ボタンや画面を作る基本道具
- `image_picker` → カメラやギャラリーから写真を選ぶ
- `db_helper.dart` → スキャンした資料を保存する

---

### ③関数って何？

**関数は「魔法の名前を付けた作業」**

料理で例えると：
```
「カレーを作る」という名前をつけた手順：
  1. 野菜を切る
  2. 肉を炒める
  3. 水を入れる
  4. ルーを入れる
  5. 煮込む
```

これを「カレーを作る」と1回呼ぶだけで全部やってくれます。

**プログラムでも同じ：**
```dart
void カメラを開く() {
  // カメラを起動する処理
  // 撮影する処理
  // 写真を保存する処理
}

// 使うとき
カメラを開く();  // ← これだけで全部やってくれる！
```

**このアプリの主な関数たち：**
- `main()` → アプリを起動する（最初に必ず実行される特別な関数）
- `_scanDocument()` → カメラでスキャンする
- `_saveToDb()` → データベースに保存する

---

### ④ifって何？

**ifは「もし〜なら」という条件分岐**

日常生活で例えると：
```
もし 雨が降っている なら
  傘を持っていく
そうじゃなければ
  傘はいらない
```

**プログラムでも同じ：**
```dart
if (雨が降っている) {
  傘を持っていく;
} else {
  傘はいらない;
}
```

**このアプリでの使用例：**
```dart
if (_apiKey.isEmpty) {
  // もしAPIキーが空なら
  debugPrint("【警告】APIキーが設定されていません");
} else {
  // そうじゃなければ（APIキーがあるなら）
  debugPrint("✅ APIキー設定確認");
}
```

```dart
if (_isTosAccepted) {
  // もし利用規約に同意したなら
  メイン画面を表示();
} else {
  // そうじゃなければ
  利用規約画面を表示();
}
```

---

### ⑤このアプリの全体の流れ（超シンプル版）

```
【アプリ起動】
   ↓
[1] .envファイルからAPIキーを読み込む
   ↓
[2] 広告機能を準備する
   ↓
[3] 利用規約に同意したかチェック
   ↓
   ├─ 同意済み → メイン画面へ
   └─ 未同意 → 利用規約画面へ
       ↓
      （同意ボタンを押す）
       ↓
     メイン画面へ

【メイン画面】
   ↓
[4] スキャンボタンを押す
   ↓
[5] カメラで資料を撮影
   ↓
[6] Gemini AIに「これは何の資料？」と聞く
   ↓
[7] AI「これは数学の試験用紙です」と回答
   ↓
[8] データベースに保存
   ↓
[9] リストに表示される
```

---

### ⑥「変数」って何？（補足）

**変数は「名札をつけた箱」**

```dart
String 名前 = "太郎";
int 年齢 = 20;
bool テストに合格した = true;
```

- `String` → 文字を入れる箱
- `int` → 数字を入れる箱
- `bool` → true（はい）か false（いいえ）を入れる箱

**このアプリでよく出てくる変数：**
```dart
String _apiKey = "xxxxx";  // Gemini APIキーを入れる箱
bool _isTosAccepted = false;  // 利用規約に同意したか
List<Map<String, dynamic>> _documents = [];  // スキャンした資料のリスト
```

---

## �📚 **フェーズ1：アプリの起動と初期化**

### 仕組み
- [`lib/main.dart`](lib/main.dart)の`main()`関数で初期化処理
- **処理内容**：
  1. `.env`ファイルから**Gemini APIキー**を読み込み
  2. Google Mobile Adsを初期化（広告表示用）
  3. デバイス情報をデバッグ表示
  4. Gemini APIキーが有効かテスト

### コード解説
```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // .env ファイルを読み込む
  await dotenv.load(fileName: ".env");
  _apiKey = dotenv.env['GEMINI_API_KEY'] ?? '';
  
  await MobileAds.instance.initialize();
  
  // API キー有効性テスト
  final analyzer = GeminiAnalyzer(apiKey: _apiKey);
  await analyzer.testApiKey();
  
  runApp(const MyApp());
}
```

### 学んだこと
- `WidgetsFlutterBinding.ensureInitialized()`は非同期処理前に必須
- APIキーは**.env**ファイルで管理してセキュア
- `flutter_dotenv`パッケージで環境変数を扱える

---

## 📚 **フェーズ2：利用規約の同意チェック**

### 仕組み
- `SharedPreferences`を使って、ユーザーが利用規約に同意したか確認
- 初回起動時は**利用規約画面**を表示
- 同意後は**メイン画面**（DashboardScreen）へ

### コード解説
```dart
class _MyAppState extends State<MyApp> {
  bool? _isTosAccepted;

  Future<void> _checkTosStatus() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _isTosAccepted = prefs.getBool('is_tos_accepted') ?? false;
    });
  }

  @override
  Widget build(BuildContext context) {
    // 同意済みならDashboard、未同意なら規約画面
    return MaterialApp(
      home: _isTosAccepted! ? const DashboardScreen() : const TermsOfServicePage(),
    );
  }
}
```

### 学んだこと
- `SharedPreferences`でアプリ内に小規模データを保存できる
- 三項演算子で画面の出し分けができる
- 利用規約は法的トラブル回避に重要

---

## 📚 **フェーズ3：データベース設計（SQLite）**

### 仕組み
- [`lib/db_helper.dart`](lib/db_helper.dart)でSQLiteを管理
- **2つのテーブル**を使用：
  1. **documents**：スキャンしたドキュメントを保存
  2. **keywords**：ユーザー独自の分類ルール

### テーブル構造
```dart
// documentsテーブル
CREATE TABLE documents (
  _id INTEGER PRIMARY KEY,
  doc_type TEXT NOT NULL,      // ドキュメント種別（試験用紙/ノート/レポート）
  subject TEXT NOT NULL,        // 科目名
  tag TEXT NOT NULL,            // 詳細タグ（教授名、イベント名など）
  period TEXT,                  // 時期情報（2024年度など）
  content TEXT NOT NULL,        // OCRで認識したテキスト
  date TEXT NOT NULL,           // 追加日時
  image_path TEXT,              // 画像ファイルのパス
  file_hash TEXT UNIQUE         // 重複防止用ハッシュ
);

// keywordsテーブル
CREATE TABLE keywords (
  _id INTEGER PRIMARY KEY,
  keyword TEXT NOT NULL UNIQUE,     // キーワード
  rule_subject TEXT NOT NULL        // 優先的に分類する科目名
);
```

### 学んだこと
- `sqflite`パッケージでFlutterでもSQLiteが使える
- **file_hash**で重複チェックができる（`md5`ハッシュ）
- インデックスを貼ると検索速度が向上

---

## 📚 **フェーズ4：メイン画面の構成**

### 仕組み
- [`lib/main.dart`](lib/main.dart)の`DashboardScreen`がホーム画面
- **科目名ごとにフォルダ分け**して表示
- フォルダをタップ → その科目のドキュメント一覧

### 画面構成
```
┌─────────────────────────┐
│   [TV アイコン]          │  ← ユーザー辞書
├─────────────────────────┤
│  ┌────┐  ┌────┐        │
│  │数学│  │物理│        │  ← 科目フォルダ（GridView）
│  └────┘  └────┘        │
│  ┌────┐  ┌────┐        │
│  │英語│  │化学│        │
│  └────┘  └────┘        │
├─────────────────────────┤
│ [📷] [📁] [+]           │  ← 下部操作ボタン
└─────────────────────────┘
```

### コード解説
```dart
GridView.builder(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,  // 2列表示
  ),
  itemCount: _subjectFolders.length,
  itemBuilder: (ctx, i) {
    String subjectName = _subjectFolders.keys.elementAt(i);
    return GestureDetector(
      onTap: () => Navigator.push(...),  // タップで詳細画面へ
      onLongPress: () => _showFolderMenu(...),  // 長押しで編集メニュー
      child: Stack(
        children: [
          Image.asset('assets/clipboard.png'),  // クリップボード画像
          Text(subjectName),  // 科目名
        ],
      ),
    );
  },
);
```

### 学んだこと
- `GridView.builder`で効率的にグリッド表示
- `GestureDetector`で「タップ」と「長押し」を分けられる
- `Stack`で画像とテキストを重ねられる

---

## 📚 **フェーズ5：ドキュメントスキャン（カメラ撮影）**

### 仕組み
1. カメラボタンをタップ
2. `cunning_document_scanner`パッケージでスキャン
3. 自動で**台形補正**と**ホワイトバランス調整**
4. スキャンした画像をファイルで保存

### コード解説
```dart
Future<void> _scanDocument() async {
  try {
    List<String> pictures = await CunningDocumentScanner.getPictures() ?? [];
    if (pictures.isEmpty) return;

    List<File> files = pictures.map((path) => File(path)).toList();
    await _startAnalysis(files);  // AI解析へ
  } catch (e) {
    debugPrint("スキャンエラー: $e");
  }
}
```

### 学んだこと
- `cunning_document_scanner`は書類スキャンに特化
- 自動で**エッジ検出**してくれるので超便利
- 複数枚を一度にスキャン可能

---

## 📚 **フェーズ6：Gemini AIによる自動分類**

### 仕組み（最重要！）
1. スキャンした画像を**Gemini AI**に送信
2. プロンプトで「ドキュメント種別 / 科目名 / 詳細タグ / 時期情報」を抽出するよう指示
3. AIの回答を解析してDBに保存

### コード解説（[`lib/gemini_analyzer.dart`](lib/gemini_analyzer.dart)）
```dart
Future<String> processSingleImage(File file) async {
  final bytes = await file.readAsBytes();
  final hash = md5.convert(bytes).toString();  // 重複チェック用

  // Geminiにリクエスト
  final model = GenerativeModel(model: 'gemini-3-flash-preview', apiKey: apiKey);
  final prompt = TextPart(
    "この画像は学習用ドキュメントです。ファイリングのために以下の情報を抽出してください。\n\n"
    "【出力フォーマット】\n"
    "必ず以下の順序で、スラッシュ区切りで出力してください。\n"
    "『ドキュメント種別 / 科目名 / 詳細タグ / 時期情報』\n"
    "（例: 試験用紙 / 熱力学 / 佐藤教授 / 2024年度）\n"
  );

  final response = await model.generateContent([
    Content.multi([prompt, DataPart('image/jpeg', bytes)])
  ]);

  String result = response.text ?? "不明 / 不明 / 不明 / 不明";
  
  // DBに保存
  List<String> parts = result.split(" / ");
  await DBHelper.instance.insertDocument(
    docType: parts[0],
    subject: parts[1],
    tag: parts[2],
    period: parts[3],
    content: "AI解析完了",
    imagePath: file.path,
    fileHash: hash,
  );

  return result;
}
```

### プロンプトの工夫
- **フォーマット指定**で構造化された回答を取得
- **キーワード優先ルール**をプロンプトに含めることで精度向上
- **前回の解析結果**を渡すことで文脈を継承（連続した資料の場合）

### 学んだこと
- Gemini APIは画像とテキストを同時に送信できる（マルチモーダル）
- プロンプトエンジニアリングが超重要
- `DataPart('image/jpeg', bytes)`で画像データを送れる

---

## 📚 **フェーズ7：重複防止とハッシュチェック**

### 仕組み
- 同じ画像を2回追加しないように**MD5ハッシュ**でチェック
- ファイル内容が1バイトでも異なれば別のハッシュ値

### コード解説
```dart
final bytes = await file.readAsBytes();
final hash = md5.convert(bytes).toString();

// 重複チェック
if (await DBHelper.instance.isDuplicate(hash)) {
  return "重複スキップ";
}
```

### 学んだこと
- `crypto`パッケージで簡単にハッシュ計算
- 同じ画像を何度スキャンしても1回しか保存されない
- `UNIQUE`制約でDB側でも重複を防げる

---

## 📚 **フェーズ8：ユーザー辞書機能（キーワードルール）**

### 仕組み
- テレビのアイコンをタップ → [`TvDictionaryScreen`](lib/main.dart#L1338)
- 「このキーワードがあったらこの科目に分類」というルールを登録
- AI解析時にプロンプトに自動挿入される

### 使用例
- キーワード：「熱力学」 → 科目：「物理学」
- キーワード：「佐藤教授」 → 科目：「化学」

### コード解説
```dart
// キーワードルールをプロンプトに追加
final rules = await DBHelper.instance.getAllKeywordRules();
String dictText = "【重要：キーワード優先ルール】\n";
for (var rule in rules) {
  dictText += "・「${rule['keyword']}」→ 科目：「${rule['rule_subject']}」\n";
}

final prompt = TextPart("$basePrompt\n$dictText");
```

### 学んだこと
- ユーザーの独自ルールを学習させることで精度大幅アップ
- プロンプトインジェクションのリスクは要注意
- 辞書データもSQLiteで永続化

---

## 📚 **フェーズ9：階層構造の画面遷移**

### 画面遷移の流れ
```
DashboardScreen（科目一覧）
   ↓ タップ
TagListScreen（タグ一覧）
   ↓ タップ
DocumentListScreen（ドキュメント一覧）
   ↓ タップ
DocumentDetailScreen（詳細表示）
```

### 各階層の役割
1. **科目一覧**：「数学」「物理」などのフォルダ
2. **タグ一覧**：「中間試験」「佐藤教授」などで細分化
3. **ドキュメント一覧**：実際のスキャン画像リスト
4. **詳細画面**：画像の拡大表示、OCRテキスト表示

### コード解説
```dart
// タップで次の階層へ遷移
GestureDetector(
  onTap: () {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => TagListScreen(subjectName: selectedSubject)
      ),
    ).then((_) => _refreshFolders());  // 戻ってきたら再読み込み
  },
  child: FolderWidget(...),
);
```

### 学んだこと
- `Navigator.push()`で画面遷移
- `.then()`で戻ってきた時の処理を書ける
- データの受け渡しはコンストラクタで

---

## 📚 **フェーズ10：アニメーションとUI/UX**

### 仕組み
- [`lib/anime/tae_animation.dart`](lib/anime/tae_animation.dart)でローディングアニメーション
- AI解析中にランダムなアニメーションを表示
- パターンA：PCに向かう → パターンB：突っ伏す → パターンC：揚げ物を食べる

### コード解説
```dart
final List<List<String>> _animationPatterns = [
  ['assets/PC1.png', 'assets/PC2.png'],  // PCパターン
  ['assets/print1.png', 'assets/print2.png', 'assets/print3.png'],  // 突っ伏すパターン
  ['assets/fry1.png', 'assets/fry2.png', 'assets/fry3.png'],  // 揚げ物パターン
];

Timer.periodic(Duration(milliseconds: 200), (timer) {
  setState(() {
    _currentFrameIndex = (_currentFrameIndex + 1) % pattern.length;
  });
});
```

### その他のUI工夫
- `tutorial_coach_mark`で初回起動時のチュートリアル
- `google_fonts`の「よもぎ」フォントで手書き風
- `Hero`アニメーションでTVアイコンがスムーズに遷移

### 学んだこと
- `Timer.periodic`で簡単にアニメーション実装
- `Hero`ウィジェットで画面遷移時のアニメーションが簡単
- UX向上のためローディング中は視覚的フィードバックが重要

---

## 🎯 **まとめ：アプリ全体のデータフロー**

```
1. ユーザーがカメラボタンをタップ
   ↓
2. ドキュメントスキャナーで撮影（台形補正）
   ↓
3. 画像ファイルを保存
   ↓
4. MD5ハッシュで重複チェック
   ↓
5. Gemini AIに画像とプロンプトを送信
   ↓
6. 「ドキュメント種別 / 科目 / タグ / 時期」を受信
   ↓
7. SQLiteに保存（正規化されたテーブル構造）
   ↓
8. 科目ごとにフォルダ分けしてUI表示
   ↓
9. ユーザーがタップして階層的に閲覧
```

---

## 🛠️ **技術スタック一覧**

| カテゴリ | 使用技術・パッケージ |
|---------|---------------------|
| フレームワーク | Flutter（Dart） |
| データベース | SQLite（sqflite） |
| AI | Google Gemini API（google_generative_ai） |
| スキャン | cunning_document_scanner |
| OCR | google_mlkit_text_recognition |
| 広告 | google_mobile_ads |
| UI/UX | tutorial_coach_mark, google_fonts |
| 環境変数 | flutter_dotenv |
| ハッシュ | crypto（MD5） |
| 永続化 | shared_preferences |

---

## 📝 **次のステップ：カスタマイズアイデア**

### アイデア1：OCR精度向上
- Geminiだけでなく`google_mlkit_text_recognition`も併用
- 数式認識に特化したプロンプト改善

### アイデア2：クラウド同期
- Firebase Storageで画像をクラウド保管
- Firestoreで複数デバイス間で同期

### アイデア3：手書きメモ機能
- スキャン後に画像上にペンで書き込み
- `flutter_painter`パッケージで実現可能

### アイデア4：検索機能強化
- 全文検索（FTS5）
- タグのオートコンプリート

### アイデア5：共有機能
- PDFエクスポート
- メール添付で共有

---

## 🔍 **学習のポイント**

### 初心者が学ぶべきこと
1. **Flutterの基礎**：StatefulWidget、setState、Navigator
2. **非同期処理**：async/await、Future
3. **SQLite**：CREATE TABLE、INSERT、SELECT
4. **API連携**：HTTP通信、JSONパース

### 中級者が深掘りすべきこと
1. **プロンプトエンジニアリング**：AIの回答品質を高める技術
2. **データベース設計**：正規化、インデックス、マイグレーション
3. **状態管理**：Provider、Riverpodへの移行
4. **パフォーマンス最適化**：ListViewのlazy loading

### 上級者向けの改善点
1. **アーキテクチャ**：Clean Architecture、MVVM導入
2. **テスト**：Unit Test、Widget Test、Integration Test
3. **CI/CD**：Codemagic、GitHub Actionsで自動ビルド
4. **セキュリティ**：APIキーの難読化、SSL Pinning

---

## 🎓 **このアプリから学べる重要な概念**

### 1. MVCパターンの理解
- **Model**：DBHelper（データ層）
- **View**：各Screenウィジェット（UI層）
- **Controller**：Stateクラスのメソッド（ロジック層）

### 2. 非同期処理の連鎖
```dart
await dotenv.load();               // 1. 環境変数読み込み
await MobileAds.instance.initialize();  // 2. 広告初期化
await analyzer.testApiKey();       // 3. APIテスト
runApp(const MyApp());             // 4. アプリ起動
```

### 3. エラーハンドリング
```dart
try {
  final result = await analyzer.processSingleImage(file);
} on FormatException catch (e) {
  print("フォーマットエラー: $e");
} catch (e) {
  print("予期しないエラー: $e");
}
```

### 4. ウィジェットツリーの最適化
- `ListView.builder`で大量データも高速表示
- `const`コンストラクタで再ビルドを削減

---

## 📖 **参考になったドキュメント**

- [Flutter公式ドキュメント](https://docs.flutter.dev/)
- [Gemini API リファレンス](https://ai.google.dev/docs)
- [SQLiteチュートリアル](https://www.sqlitetutorial.net/)
- [Dartの非同期処理](https://dart.dev/codelabs/async-await)

---

## ✅ **次回の開発課題**

- [ ] PDF出力機能の追加
- [ ] ダークモード対応
- [ ] 検索機能の実装
- [ ] Firebase連携
- [ ] ウィジェット分割でコードの可読性向上
- [ ] エラーログの収集（Crashlytics）
- [ ] パフォーマンス測定（Flutter DevTools）

---

## 🎓 **実際のコードで理解を深めよう**

ここから、`main.dart`の実際のコードを見ながら、1行ずつ理解していきましょう。

### 📖 main.dartの最初の部分を読み解く

```dart
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
```

**解説：**
- `import 'dart:io';` → ファイルを扱う道具（写真を保存する時に使う）
- `import 'package:flutter/material.dart';` → 画面やボタンを作る道具
- `import 'package:image_picker/image_picker.dart';` → カメラやギャラリーから写真を選ぶ道具

---

### 📖 アプリが起動する瞬間（main関数）

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  await dotenv.load(fileName: ".env");
  _apiKey = dotenv.env['GEMINI_API_KEY'] ?? '';
  
  await MobileAds.instance.initialize();
  
  runApp(const MyApp());
}
```

**1行ずつ解説：**

1. `void main() async {`
   - **void** → この関数は何も返さない
   - **main** → アプリが起動したら一番最初に実行される特別な関数
   - **async** → 時間がかかる処理（ファイル読み込みなど）を待つことができる

2. `WidgetsFlutterBinding.ensureInitialized();`
   - Flutterの準備をする（おまじないみたいなもの）
   - 「これから色々なことをするから準備して！」とFlutterに伝える

3. `await dotenv.load(fileName: ".env");`
   - **await** → 「待って！」という意味。ファイル読み込みが終わるまで次に進まない
   - **.envファイル**を読み込む（ここにGemini APIキーが書かれている）

4. `_apiKey = dotenv.env['GEMINI_API_KEY'] ?? '';`
   - **=** → 右側の値を左側の箱に入れる
   - `dotenv.env['GEMINI_API_KEY']` → .envファイルから「GEMINI_API_KEY」という名前の値を取り出す
   - **??** → もし左側がnull（何もない）なら右側を使う
   - つまり「APIキーが見つかったらそれを使うけど、なかったら空っぽの文字に」という意味

5. `await MobileAds.instance.initialize();`
   - 広告機能を初期化（準備）する

6. `runApp(const MyApp());`
   - ついにアプリを起動！`MyApp()`という画面を表示する

---

### 📖 「もし利用規約に同意してたら」の部分

```dart
class _MyAppState extends State<MyApp> {
  bool? _isTosAccepted;

  @override
  void initState() {
    super.initState();
    _checkTosStatus();
  }

  Future<void> _checkTosStatus() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _isTosAccepted = prefs.getBool('is_tos_accepted') ?? false;
    });
  }

  @override
  Widget build(BuildContext context) {
    if (_isTosAccepted == null) {
      return MaterialApp(
        home: const Scaffold(
          backgroundColor: Color(0xFF3E2723),
          body: Center(child: CircularProgressIndicator()),
        ),
      );
    }

    return MaterialApp(
      home: _isTosAccepted! ? const DashboardScreen() : const TermsOfServicePage(),
    );
  }
}
```

**解説：**

1. `bool? _isTosAccepted;`
   - **bool?** → trueかfalseか、または「まだ分からない（null）」を入れられる箱
   - アプリが起動した直後は「まだチェックしてない」ので null

2. `initState()`
   - この画面が表示される時に**1回だけ**実行される関数
   - ここで `_checkTosStatus()` を呼んで、同意したかチェック

3. `_checkTosStatus()` 関数
   - `SharedPreferences` → スマホの中に小さなメモを保存できる機能
   - `prefs.getBool('is_tos_accepted')` → 「is_tos_acceptedという名前のメモを読む」
   - もしメモがなかったら `??false` で「同意してない」と判断

4. `if (_isTosAccepted == null)`
   - **もしまだチェック中なら**くるくるマーク（ローディング）を表示

5. `_isTosAccepted! ? const DashboardScreen() : const TermsOfServicePage()`
   - **? と :** → 「もし〇〇なら△△、そうじゃなければ××」という書き方
   - 同意済みなら`DashboardScreen`（メイン画面）
   - 同意してないなら`TermsOfServicePage`（利用規約画面）

---

### 📖 データを保存する部分（SQLite）

```dart
Future<void> _saveToDb() async {
  String docType = _selectedDocType ?? '';
  String subject = _subjectController.text.trim();
  String tag = _tagController.text.trim();
  
  if (docType.isEmpty || subject.isEmpty) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('ドキュメント種別と科目を入力してください'))
    );
    return;
  }

  await DBHelper().insertDocument({
    'doc_type': docType,
    'subject': subject,
    'tag': tag,
    'content': _recognizedText,
    'image_path': _imagePath,
  });

  Navigator.of(context).pop();
}
```

**1行ずつ解説：**

1. `Future<void> _saveToDb() async`
   - 時間がかかる処理（データベースへの保存）を行う関数

2. `String docType = _selectedDocType ?? '';`
   - ドキュメント種別（試験用紙/ノート/レポート）を変数に入れる
   - もし選んでなかったら空っぽの文字に

3. `if (docType.isEmpty || subject.isEmpty)`
   - **isEmpty** → 空っぽかどうかチェック
   - **||** → 「または」という意味
   - つまり「ドキュメント種別が空っぽ、または、科目が空っぽなら」

4. `ScaffoldMessenger.of(context).showSnackBar(...)`
   - 画面の下に「入力してください」というメッセージを表示
   - `return;` で関数を終了（保存しない）

5. `await DBHelper().insertDocument({...})`
   - データベースに保存！
   - `{...}` の中に保存したいデータを書く

6. `Navigator.of(context).pop();`
   - この画面を閉じて、前の画面に戻る

---

### 📖 Gemini AIに聞く部分（AI分類）

```dart
Future<void> _analyzeDocument() async {
  if (_recognizedText.isEmpty) {
    return;
  }

  setState(() => _isAnalyzing = true);

  try {
    final analyzer = GeminiAnalyzer(apiKey: _apiKey);
    final result = await analyzer.analyzeDocument(_recognizedText);

    setState(() {
      _selectedDocType = result['doc_type'];
      _subjectController.text = result['subject'] ?? '';
      _tagController.text = result['tag'] ?? '';
      _isAnalyzing = false;
    });
  } catch (e) {
    setState(() => _isAnalyzing = false);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('分析エラー: $e'))
    );
  }
}
```

**解説：**

1. `if (_recognizedText.isEmpty) { return; }`
   - もしテキストが認識されてなかったら何もしない

2. `setState(() => _isAnalyzing = true);`
   - **setState** → 画面を更新する命令
   - 「今、AIに聞いてます」という状態にする（ローディング表示）

3. `try { ... } catch (e) { ... }`
   - **try** → これから危険な処理をします
   - **catch** → もしエラーが起きたらこっちを実行
   - エラーでアプリが落ちないようにする安全装置

4. `final analyzer = GeminiAnalyzer(apiKey: _apiKey);`
   - Gemini AIとやり取りする道具を準備

5. `final result = await analyzer.analyzeDocument(_recognizedText);`
   - AIに「このテキストは何の資料？」と聞く
   - **await** → 回答が返ってくるまで待つ（数秒かかる）

6. `result['doc_type']`
   - AIの回答から「ドキュメント種別」を取り出す
   - `result['subject']` → 科目名
   - `result['tag']` → タグ

---

## 🎯 **まとめ：このアプリの核心**

### アプリの動きを超シンプルに言うと：

1. **アプリ起動** → APIキーを読み込む
2. **利用規約チェック** → 同意してたらメイン画面へ
3. **スキャンボタン** → カメラで資料を撮影
4. **OCR** → 写真から文字を読み取る
5. **Gemini AI** → 「これは〇〇の試験用紙です」と判定
6. **データベース** → 保存
7. **リスト表示** → 科目ごとに整理して表示

### 重要な概念のおさらい：

| 用語 | 意味 | 例え |
|------|------|------|
| **import** | 道具を持ってくる | 料理でフライパンを準備 |
| **関数** | 名前をつけた作業 | 「カレーを作る」という手順 |
| **if** | もし〜なら | 雨なら傘を持つ |
| **変数** | 名札をつけた箱 | 「名前」という箱に「太郎」を入れる |
| **async/await** | 時間がかかる処理を待つ | AIの回答を待つ |

---

**開発日記 完成！ 🎉**

このアプリの仕組みを初歩の段階から解説しました。プログラミングは最初は難しく感じますが、**「上から順番に実行される」**というシンプルな原則だけ覚えておけばOKです。

特に**Gemini AIとの連携**が肝です。プロンプト設計次第で精度が大きく変わるので、ここを深掘りするとAI活用力が身につきます！
